<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>Crossword Client</title>
<style>
/* Modern CSS Reset and Base Styles */
* {
  box-sizing: border-box;
  margin: 0;
  padding: 0;
}

body {
  font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, Oxygen, Ubuntu, Cantarell, sans-serif;
  line-height: 1.6;
  color: #333;
  background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
  min-height: 100vh;
  padding: 20px;
}

.container {
  max-width: 1200px;
  margin: 0 auto;
  background: white;
  border-radius: 12px;
  box-shadow: 0 20px 40px rgba(0,0,0,0.1);
  overflow: hidden;
}

.header {
  background: linear-gradient(135deg, #4f46e5 0%, #7c3aed 100%);
  color: white;
  padding: 2rem;
  text-align: center;
}

.header h1 {
  font-size: 2.5rem;
  font-weight: 700;
  margin-bottom: 0.5rem;
}

.header p {
  opacity: 0.9;
  font-size: 1.1rem;
}

.content {
  padding: 2rem;
}

.section {
  background: #f8fafc;
  border-radius: 8px;
  padding: 1.5rem;
  margin-bottom: 2rem;
  border: 1px solid #e2e8f0;
}

.section h2 {
  color: #1e293b;
  font-size: 1.5rem;
  margin-bottom: 1rem;
  display: flex;
  align-items: center;
  gap: 0.5rem;
}

.section h3 {
  color: #475569;
  font-size: 1.25rem;
  margin-bottom: 1rem;
}

/* File Loading Section */
.file-section {
  background: linear-gradient(135deg, #dbeafe 0%, #bfdbfe 100%);
  border: 1px solid #3b82f6;
}

/* Configuration Section */
.config-grid {
  display: grid;
  grid-template-columns: repeat(auto-fit, minmax(250px, 1fr));
  gap: 1rem;
  margin-bottom: 1.5rem;
}

.input-group {
  display: flex;
  flex-direction: column;
}

.input-group label {
  font-weight: 600;
  color: #374151;
  margin-bottom: 0.5rem;
  font-size: 0.9rem;
}

.input-group input {
  padding: 0.75rem;
  border: 2px solid #d1d5db;
  border-radius: 6px;
  font-size: 1rem;
  transition: all 0.2s ease;
}

.input-group input:focus {
  outline: none;
  border-color: #4f46e5;
  box-shadow: 0 0 0 3px rgba(79, 70, 229, 0.1);
}

.input-group input:invalid {
  border-color: #ef4444;
}

/* Buttons */
.btn {
  display: inline-flex;
  align-items: center;
  gap: 0.5rem;
  padding: 0.75rem 1.5rem;
  border: none;
  border-radius: 6px;
  font-size: 1rem;
  font-weight: 600;
  cursor: pointer;
  transition: all 0.2s ease;
  text-decoration: none;
}

.btn:hover {
  transform: translateY(-1px);
  box-shadow: 0 4px 12px rgba(0,0,0,0.15);
}

.btn-primary {
  background: linear-gradient(135deg, #4f46e5 0%, #7c3aed 100%);
  color: white;
}

.btn-primary:hover {
  background: linear-gradient(135deg, #4338ca 0%, #6d28d9 100%);
}

.btn-success {
  background: linear-gradient(135deg, #059669 0%, #047857 100%);
  color: white;
}

.btn-success:hover {
  background: linear-gradient(135deg, #047857 0%, #065f46 100%);
}

.btn-secondary {
  background: linear-gradient(135deg, #6b7280 0%, #4b5563 100%);
  color: white;
}

.btn-secondary:hover {
  background: linear-gradient(135deg, #4b5563 0%, #374151 100%);
}

.btn-print {
  background: linear-gradient(135deg, #7c2d12 0%, #92400e 100%);
  color: white;
}

.btn-print:hover {
  background: linear-gradient(135deg, #92400e 0%, #a16207 100%);
}

.btn-warning {
  background: linear-gradient(135deg, #f59e0b 0%, #d97706 100%);
  color: white;
}

.btn-warning:hover {
  background: linear-gradient(135deg, #d97706 0%, #b45309 100%);
}

/* Status Messages */
.status-message {
  padding: 1rem;
  border-radius: 6px;
  margin-top: 1rem;
  font-weight: 500;
}

.status-success {
  background: #dcfce7;
  color: #166534;
  border: 1px solid #bbf7d0;
}

.status-error {
  background: #fef2f2;
  color: #dc2626;
  border: 1px solid #fecaca;
}

/* Messages Section */
.messages-container {
  background: #1f2937;
  border-radius: 6px;
  padding: 1rem;
  max-height: 300px;
  overflow-y: auto;
}

.messages-list {
  list-style: none;
}

.messages-list li {
  background: #374151;
  color: #f3f4f6;
  padding: 0.75rem;
  margin-bottom: 0.5rem;
  border-radius: 4px;
  font-family: 'Courier New', monospace;
  font-size: 0.9rem;
  border-left: 3px solid #4f46e5;
}

.messages-list li:last-child {
  margin-bottom: 0;
}

.messages-empty {
  color: #9ca3af;
  font-style: italic;
  text-align: center;
  padding: 2rem;
}

/* Tables */
.table-container {
  overflow-x: auto;
  border-radius: 6px;
  border: 1px solid #e5e7eb;
}

table {
  width: 100%;
  border-collapse: collapse;
  background: white;
}

th {
  background: #f9fafb;
  color: #374151;
  font-weight: 600;
  padding: 1rem;
  text-align: left;
  border-bottom: 2px solid #e5e7eb;
}

td {
  padding: 0.75rem 1rem;
  border-bottom: 1px solid #f3f4f6;
}

tr:hover {
  background: #f8fafc;
}

th.idCol, td.idCol {
  text-align: right;
  font-family: 'Courier New', monospace;
  font-weight: 600;
}

/* Canvas */
.canvas-container {
  text-align: center;
  padding: 1rem;
  background: white;
  border-radius: 6px;
  border: 1px solid #e5e7eb;
  margin-bottom: 1rem;
}

canvas {
  border: 2px solid #d1d5db;
  border-radius: 4px;
  box-shadow: 0 4px 6px rgba(0,0,0,0.1);
  max-width: 100%;
  height: auto;
}

/* Clues Layout */
.clues-container {
  display: grid;
  grid-template-columns: 1fr 1fr;
  gap: 2rem;
  margin-top: 1rem;
}

@media (max-width: 768px) {
  .clues-container {
    grid-template-columns: 1fr;
  }
  
  .config-grid {
    grid-template-columns: 1fr;
  }
  
  .header h1 {
    font-size: 2rem;
  }
  
  .content {
    padding: 1rem;
  }
}

/* Section Headers with Actions */
.section-header {
  display: flex;
  justify-content: space-between;
  align-items: center;
  margin-bottom: 1rem;
  flex-wrap: wrap;
  gap: 1rem;
}

.section-header h2,
.section-header h3 {
  margin: 0;
}

/* Hidden elements */
.hidden {
  display: none !important;
}

/* Icons (using Unicode symbols) */
.icon {
  font-size: 1.2em;
  margin-right: 0.25rem;
}

/* Loading animation */
@keyframes pulse {
  0%, 100% { opacity: 1; }
  50% { opacity: 0.5; }
}

.loading {
  animation: pulse 2s infinite;
}

/* Word Entry Table Styles */
.word-entry-row input {
  width: 100%;
  padding: 0.5rem;
  border: 1px solid #d1d5db;
  border-radius: 4px;
  font-size: 0.9rem;
  background: white;
}

.word-entry-row input:focus {
  outline: none;
  border-color: #4f46e5;
  box-shadow: 0 0 0 2px rgba(79, 70, 229, 0.1);
}

.word-entry-row .word-input {
  font-family: 'Courier New', monospace;
  font-weight: 600;
  text-transform: uppercase;
}

.word-entry-row .explanation-input {
  font-family: inherit;
}

.remove-row-btn {
  background: #ef4444;
  color: white;
  border: none;
  border-radius: 4px;
  padding: 0.25rem 0.5rem;
  cursor: pointer;
  font-size: 0.8rem;
  transition: background-color 0.2s;
}

.remove-row-btn:hover {
  background: #dc2626;
}
</style>
</head>
<body>
<div class="container">
  <div class="header">
    <h1><span class="icon">üß©</span>Crossword Client</h1>
    <p>Professional crossword puzzle generator and solver</p>
  </div>

  <div class="content">
    <!-- File Loading Section -->
    <div class="section file-section">
      <h2><span class="icon">üìÅ</span>Load Crossword File</h2>
      <p style="margin-bottom: 1rem; color: #1e40af;">Select a .cross file containing your word entries and explanations.</p>
      <div style="display: flex; gap: 1rem; flex-wrap: wrap;">
        <button id="loadButton" class="btn btn-primary">
          <span class="icon">‚¨ÜÔ∏è</span>Choose File
        </button>
        <button id="saveButton" class="btn btn-secondary">
          <span class="icon">üíæ</span>Save as .cross
        </button>
      </div>
      <input type="file" id="fileInput" accept=".cross" class="hidden" />
      <div id="fileStatus" class="status-message hidden"></div>
    </div>

    <!-- Word Entry Editor Section -->
    <div class="section">
      <div class="section-header">
        <h2><span class="icon">‚úèÔ∏è</span>Word Entry Editor</h2>
        <div style="display: flex; gap: 0.5rem; flex-wrap: wrap;">
          <button id="addRowButton" class="btn btn-success">
            <span class="icon">‚ûï</span>Add Word
          </button>
          <button id="clearAllButton" class="btn btn-secondary">
            <span class="icon">üóëÔ∏è</span>Clear All
          </button>
        </div>
      </div>
      <div class="table-container">
        <table id="wordEntryTable">
          <thead>
            <tr>
              <th style="width: 30%;">Word</th>
              <th style="width: 60%;">Explanation/Clue</th>
              <th style="width: 10%;">Actions</th>
            </tr>
          </thead>
          <tbody id="wordEntryTableBody">
            <!-- Rows will be added dynamically -->
          </tbody>
        </table>
      </div>
      <div id="entryCount" style="margin-top: 0.5rem; color: #6b7280; font-size: 0.9rem;">
        0 entries
      </div>
    </div>

    <!-- Configuration Section -->
    <div class="section">
      <h2><span class="icon">‚öôÔ∏è</span>Grid Configuration</h2>
      <div class="config-grid">
        <div class="input-group">
          <label for="rowsInput">Number of Rows</label>
          <input type="number" id="rowsInput" min="1" placeholder="e.g., 15">
        </div>
        <div class="input-group">
          <label for="colsInput">Number of Columns</label>
          <input type="number" id="colsInput" min="1" placeholder="e.g., 15">
        </div>
        <div class="input-group">
          <label for="maxRowsInput">Maximum Rows</label>
          <input type="number" id="maxRowsInput" min="1" placeholder="e.g., 20">
        </div>
        <div class="input-group">
          <label for="intervalInput">Interval (seconds)</label>
          <input type="number" id="intervalInput" min="1" placeholder="e.g., 5">
        </div>
      </div>
      
      <button id="submitButton" class="btn btn-success">
        <span class="icon">üöÄ</span>Generate Crossword
      </button>
      <div id="statusMessage" class="status-message hidden"></div>
    </div>

    <!-- Messages Section -->
    <div class="section">
      <h2><span class="icon">üí¨</span>Server Messages</h2>
      <div class="messages-container">
        <ul id="messages" class="messages-list">
          <li class="messages-empty">Waiting for server connection...</li>
        </ul>
      </div>
    </div>

    <!-- Solution Section -->
    <div class="section">
      <div class="section-header">
        <h2><span class="icon">‚úÖ</span>Solution</h2>
        <button id="printSolutionButton" class="btn btn-print">
          <span class="icon">üñ®Ô∏è</span>Print Solution
        </button>
      </div>
      
      <div class="clues-container">
        <div>
          <h3><span class="icon">‚û°Ô∏è</span>Horizontal Words</h3>
          <div class="table-container">
            <table id="horizontalSolution">
              <thead>
                <tr><th class="idCol">ID</th><th>Word</th></tr>
              </thead>
              <tbody></tbody>
            </table>
          </div>
        </div>
        <div>
          <h3><span class="icon">‚¨áÔ∏è</span>Vertical Words</h3>
          <div class="table-container">
            <table id="verticalSolution">
              <thead>
                <tr><th class="idCol">ID</th><th>Word</th></tr>
              </thead>
              <tbody></tbody>
            </table>
          </div>
        </div>
      </div>
    </div>

    <!-- Game Section -->
    <div class="section">
      <div class="section-header">
        <h2><span class="icon">üéÆ</span>Crossword Game</h2>
        <button id="printButton" class="btn btn-print">
          <span class="icon">üñ®Ô∏è</span>Print Game
        </button>
      </div>

      <div class="canvas-container">
        <canvas id="gridCanvas" class="hidden"></canvas>
        <div id="canvasPlaceholder" class="messages-empty">Grid will appear here after generation</div>
      </div>

      <div class="clues-container">
        <div>
          <h3><span class="icon">‚û°Ô∏è</span>Horizontal Clues</h3>
          <div class="table-container">
            <table id="horizontalClues">
              <thead>
                <tr><th class="idCol">ID</th><th>Clue</th></tr>
              </thead>
              <tbody></tbody>
            </table>
          </div>
        </div>
        <div>
          <h3><span class="icon">‚¨áÔ∏è</span>Vertical Clues</h3>
          <div class="table-container">
            <table id="verticalClues">
              <thead>
                <tr><th class="idCol">ID</th><th>Clue</th></tr>
              </thead>
              <tbody></tbody>
            </table>
          </div>
        </div>
      </div>
    </div>
  </div>
</div>

<script>
let ws;
let entries = [];
let rows = 0, cols = 0, max_rows = 0, interval = 0;

// WebSocket connection with better error handling
function connectWebSocket() {
  try {
    ws = new WebSocket("ws://localhost:9002");
    
    ws.onopen = () => {
      console.log("WebSocket connected");
      updateMessages("‚úÖ Connected to crossword server", "success");
    };
    
    ws.onerror = (e) => {
      console.error("WebSocket error", e);
      updateMessages("‚ùå Failed to connect to server. Make sure your crossword server is running on localhost:9002", "error");
    };
    
    ws.onclose = () => {
      console.log("WebSocket disconnected");
      updateMessages("‚ö†Ô∏è Disconnected from server", "warning");
    };
    
    ws.onmessage = handleWebSocketMessage;
  } catch (error) {
    console.error("WebSocket connection failed:", error);
    updateMessages("‚ùå WebSocket connection failed", "error");
  }
}

// Enhanced message handling
function handleWebSocketMessage(event) {
  try {
    const msg = JSON.parse(event.data);
    
    if (msg.response === "solved") {
      renderSolutionTable(msg.layouts);
      renderGrid(msg);
      renderClues(msg.layouts);
      updateMessages("üéâ Crossword generated successfully!", "success");
    } else {
      let text = "";
      let type = "info";
      
      if (msg.response === "configuration") {
        const r = parseInt(msg.rows?.replace(/"/g, "")) || 0;
        const c = parseInt(msg.cols?.replace(/"/g, "")) || 0;
        const perms = parseInt(msg.num_permutations?.replace(/"/g, "")) || 0;
        const memAvail = parseInt(msg.mem_available?.replace(/"/g, "")) || 0;
        const memUsed = parseInt(msg.mem_used?.replace(/"/g, "")) || 0;
        text = `üîÑ Trying: ${r} √ó ${c} grid, ${perms.toLocaleString()} permutations, ${memAvail}MB available, ${memUsed}MB used`;
      } else if (msg.response === "tries") {
        const perms = parseInt(msg.permutations?.replace(/"/g, "")) || 0;
        text = `‚è≥ Tried ${perms.toLocaleString()} permutations...`;
      } else if (msg.response === "unsolved") {
        text = "‚ùå Could not generate crossword. Try increasing maximum rows or interval.";
        type = "error";
      } else if (msg.response === "error") {
        text = `‚ùå Server Error: ${msg.explanation}`;
        type = "error";
      } else {
        text = `üìù ${JSON.stringify(msg, null, 2)}`;
      }
      
      updateMessages(text, type);
    }
  } catch (err) {
    console.error("Invalid message format:", err);
    updateMessages("‚ö†Ô∏è Received invalid message from server", "warning");
  }
}

// Enhanced message display
function updateMessages(text, type = "info") {
  const messagesList = document.getElementById("messages");
  const emptyMessage = messagesList.querySelector(".messages-empty");
  
  if (emptyMessage) {
    emptyMessage.remove();
  }
  
  const li = document.createElement("li");
  li.textContent = text;
  li.className = `message-${type}`;
  
  messagesList.appendChild(li);
  messagesList.scrollTop = messagesList.scrollHeight;
  
  // Limit messages to prevent memory issues
  while (messagesList.children.length > 50) {
    messagesList.removeChild(messagesList.firstChild);
  }
}

// File loading with enhanced feedback
document.getElementById("loadButton").onclick = () => {
  document.getElementById("fileInput").click();
};

document.getElementById("fileInput").addEventListener("change", (e) => {
  const file = e.target.files[0];
  const statusEl = document.getElementById("fileStatus");
  
  if (!file) return;
  
  statusEl.className = "status-message loading";
  statusEl.textContent = "Loading file...";
  statusEl.classList.remove("hidden");
  
  const reader = new FileReader();
  reader.onload = (ev) => {
    try {
      entries = ev.target.result
        .split("\n")
        .map(l => l.trim())
        .filter(l => l.includes("|"))
        .map(l => {
          const [word, explanation] = l.split("|");
          return { word: word.trim(), explanation: explanation.trim() };
        });
      
      console.log("Entries loaded:", entries);
      statusEl.className = "status-message status-success";
      statusEl.textContent = `‚úÖ Successfully loaded ${entries.length} word entries!`;
      updateMessages(`üìÅ Loaded ${entries.length} entries from ${file.name}`, "success");
      
      // Update the word entry table with loaded data
      populateWordEntryTable(entries);
    } catch (error) {
      statusEl.className = "status-message status-error";
      statusEl.textContent = "‚ùå Error reading file. Please check the format.";
      updateMessages("‚ùå Failed to load file", "error");
    }
  };
  
  reader.onerror = () => {
    statusEl.className = "status-message status-error";
    statusEl.textContent = "‚ùå Failed to read file.";
  };
  
  reader.readAsText(file);
});

// Save functionality
document.getElementById("saveButton").onclick = () => {
  const currentEntries = getEntriesFromTable();
  
  if (currentEntries.length === 0) {
    alert("‚ö†Ô∏è No entries to save. Add some words first.");
    return;
  }
  
  const content = currentEntries
    .map(entry => `${entry.word}|${entry.explanation}`)
    .join('\n');
  
  const blob = new Blob([content], { type: 'text/plain' });
  const url = window.URL.createObjectURL(blob);
  
  const a = document.createElement('a');
  a.href = url;
  a.download = 'crossword.cross';
  document.body.appendChild(a);
  a.click();
  document.body.removeChild(a);
  window.URL.revokeObjectURL(url);
  
  updateMessages(`üíæ Saved ${currentEntries.length} entries to crossword.cross`, "success");
};

// Word Entry Table Management
function addWordEntryRow(word = '', explanation = '') {
  const tbody = document.getElementById("wordEntryTableBody");
  const row = document.createElement("tr");
  row.className = "word-entry-row";
  
  row.innerHTML = `
    <td>
      <input type="text" class="word-input" placeholder="Enter word..." value="${word}" 
             oninput="this.value = this.value.toUpperCase().replace(/[^A-Z]/g, '')" maxlength="20">
    </td>
    <td>
      <input type="text" class="explanation-input" placeholder="Enter clue/explanation..." value="${explanation}" maxlength="200">
    </td>
    <td style="text-align: center;">
      <button class="remove-row-btn" onclick="removeWordEntryRow(this)" title="Remove this entry">
        ‚ùå
      </button>
    </td>
  `;
  
  tbody.appendChild(row);
  updateEntryCount();
  
  // Focus on the word input of the new row
  const wordInput = row.querySelector('.word-input');
  if (!word) {
    wordInput.focus();
  }
}

function removeWordEntryRow(button) {
  const row = button.closest('tr');
  row.remove();
  updateEntryCount();
}

function populateWordEntryTable(entriesArray) {
  const tbody = document.getElementById("wordEntryTableBody");
  tbody.innerHTML = "";
  
  entriesArray.forEach(entry => {
    addWordEntryRow(entry.word, entry.explanation);
  });
  
  // Add a few empty rows for easy editing
  if (entriesArray.length > 0) {
    addWordEntryRow();
    addWordEntryRow();
  }
}

function getEntriesFromTable() {
  const rows = document.querySelectorAll("#wordEntryTableBody .word-entry-row");
  const tableEntries = [];
  
  rows.forEach(row => {
    const word = row.querySelector('.word-input').value.trim();
    const explanation = row.querySelector('.explanation-input').value.trim();
    
    if (word && explanation) {
      tableEntries.push({ word, explanation });
    }
  });
  
  return tableEntries;
}

function updateEntryCount() {
  const validEntries = getEntriesFromTable();
  const countEl = document.getElementById("entryCount");
  countEl.textContent = `${validEntries.length} entries`;
  
  // Update the global entries array
  entries = validEntries;
}

// Button event handlers
document.getElementById("addRowButton").onclick = () => {
  addWordEntryRow();
};

document.getElementById("clearAllButton").onclick = () => {
  if (confirm("‚ö†Ô∏è Are you sure you want to clear all entries? This action cannot be undone.")) {
    document.getElementById("wordEntryTableBody").innerHTML = "";
    entries = [];
    updateEntryCount();
    updateMessages("üóëÔ∏è All entries cleared", "info");
  }
};

// Initialize with some empty rows
window.addEventListener("load", () => {
  connectWebSocket();
  
  // Add initial empty rows
  addWordEntryRow();
  addWordEntryRow();
  addWordEntryRow();
});

// Update entries array whenever table changes
document.addEventListener('input', (e) => {
  if (e.target.matches('.word-input, .explanation-input')) {
    updateEntryCount();
  }
});

// Enhanced input validation
function validateAndAssign(e, assignFunc) {
  const value = e.target.value.trim();
  const num = parseInt(value, 10);

  if (!value || isNaN(num) || num <= 0) {
    e.target.style.borderColor = "#ef4444";
    assignFunc(0);
  } else {
    e.target.style.borderColor = "#10b981";
    assignFunc(num);
  }
}

function alertIfInvalid(e) {
  const value = e.target.value.trim();
  if (value && !/^[1-9][0-9]*$/.test(value)) {
    alert("‚ö†Ô∏è Please enter a positive integer.");
    e.target.value = "";
    e.target.style.borderColor = "#ef4444";
  }
}

// Bind input events
const inputs = [
  { id: "rowsInput", setter: v => rows = v },
  { id: "colsInput", setter: v => cols = v },
  { id: "maxRowsInput", setter: v => max_rows = v },
  { id: "intervalInput", setter: v => interval = v }
];

inputs.forEach(({ id, setter }) => {
  const input = document.getElementById(id);
  input.addEventListener("input", e => validateAndAssign(e, setter));
  input.addEventListener("blur", alertIfInvalid);
});

// Enhanced input validation
function validateInputs() {
  const statusEl = document.getElementById("statusMessage");
  statusEl.classList.remove("hidden", "status-success", "status-error");

  if (!rows || !cols || !max_rows || !interval) {
    statusEl.className = "status-message status-error";
    statusEl.textContent = "‚ùå All fields must be filled with positive numbers.";
    return false;
  }
  
  // Update entries from table before validation
  entries = getEntriesFromTable();
  
  if (entries.length === 0) {
    statusEl.className = "status-message status-error";
    statusEl.textContent = "‚ùå Please add some word entries first.";
    return false;
  }
  
  statusEl.className = "status-message status-success";
  statusEl.textContent = "‚úÖ Configuration valid. Sending to server...";
  return true;
}

// Enhanced submit function
document.getElementById("submitButton").onclick = () => {
  if (!ws || ws.readyState !== WebSocket.OPEN) {
    alert("‚ùå WebSocket not connected. Please check if your server is running.");
    return;
  }
  
  if (!validateInputs()) return;

  // Clear previous data with better UX
  clearPreviousResults();
  updateMessages("üöÄ Generating crossword puzzle...", "info");

  // Get fresh entries from table to ensure we have the latest data
  const currentEntries = getEntriesFromTable();

  // Send request
  const request = {
    request: "create",
    rows,
    cols,
    max_rows,
    interval,
    entries: currentEntries
  };
  
  console.log("Current entries from table:", currentEntries);
  console.log("Full request being sent:", JSON.stringify(request, null, 2));
  
  ws.send(JSON.stringify(request));
};

// Clear previous results
function clearPreviousResults() {
  // Clear messages (keep connection status)
  const messagesList = document.getElementById("messages");
  const messages = Array.from(messagesList.children);
  messages.forEach(msg => {
    if (!msg.textContent.includes("Connected") && !msg.textContent.includes("Disconnected")) {
      msg.remove();
    }
  });
  
  // Clear canvas
  const canvas = document.getElementById("gridCanvas");
  const ctx = canvas.getContext("2d");
  ctx.clearRect(0, 0, canvas.width, canvas.height);
  canvas.classList.add("hidden");
  document.getElementById("canvasPlaceholder").style.display = "block";
  
  // Clear tables
  document.getElementById("horizontalClues").querySelector("tbody").innerHTML = "";
  document.getElementById("verticalClues").querySelector("tbody").innerHTML = "";
  document.getElementById("horizontalSolution").querySelector("tbody").innerHTML = "";
  document.getElementById("verticalSolution").querySelector("tbody").innerHTML = "";
}

// Enhanced print functions
document.getElementById("printButton").onclick = () => {
  const canvas = document.getElementById("gridCanvas");
  if (canvas.classList.contains("hidden")) {
    alert("‚ö†Ô∏è No crossword grid to print. Generate a crossword first.");
    return;
  }
  
  const imgData = canvas.toDataURL("image/png");
  const horizTable = document.getElementById("horizontalClues").outerHTML;
  const vertTable = document.getElementById("verticalClues").outerHTML;
  
  const printWindow = window.open("", "_blank");
  printWindow.document.write(`
    <html>
      <head>
        <title>Crossword Puzzle</title>
        <style>
          body { font-family: Arial, sans-serif; margin: 20px; }
          img { max-width: 100%; margin-bottom: 20px; }
          .clues { display: flex; gap: 40px; }
          .clues > div { flex: 1; }
          table { border-collapse: collapse; width: 100%; }
          th, td { border: 1px solid #333; padding: 8px; text-align: left; }
          th { background: #f5f5f5; }
          .idCol { text-align: right; font-family: monospace; }
        </style>
      </head>
      <body>
        <h1>üß© Crossword Puzzle</h1>
        <img src="${imgData}" alt="Crossword Grid" />
        <div class="clues">
          <div><h2>‚û°Ô∏è Horizontal</h2>${horizTable}</div>
          <div><h2>‚¨áÔ∏è Vertical</h2>${vertTable}</div>
        </div>
      </body>
    </html>
  `);
  printWindow.document.close();
  printWindow.onload = () => {
    printWindow.print();
    printWindow.close();
  };
};

document.getElementById("printSolutionButton").onclick = () => {
  const horizSolution = document.getElementById("horizontalSolution");
  const vertSolution = document.getElementById("verticalSolution");
  
  if (horizSolution.querySelector("tbody").children.length === 0 && 
      vertSolution.querySelector("tbody").children.length === 0) {
    alert("‚ö†Ô∏è No solution to print. Generate a crossword first.");
    return;
  }
  
  const printWindow = window.open("", "_blank");
  printWindow.document.write(`
    <html>
      <head>
        <title>Crossword Solution</title>
        <style>
          body { font-family: Arial, sans-serif; margin: 20px; }
          .solution { display: flex; gap: 40px; }
          .solution > div { flex: 1; }
          table { border-collapse: collapse; width: 100%; }
          th, td { border: 1px solid #333; padding: 8px; text-align: left; }
          th { background: #f5f5f5; }
          .idCol { text-align: right; font-family: monospace; }
        </style>
      </head>
      <body>
        <h1>‚úÖ Crossword Solution</h1>
        <div class="solution">
          <div><h2>‚û°Ô∏è Horizontal Words</h2>${horizSolution.outerHTML}</div>
          <div><h2>‚¨áÔ∏è Vertical Words</h2>${vertSolution.outerHTML}</div>
        </div>
      </body>
    </html>
  `);
  printWindow.document.close();
  printWindow.onload = () => {
    printWindow.print();
    printWindow.close();
  };
};

// Enhanced rendering functions
function renderSolutionTable(layouts) {
  const horizTbody = document.getElementById("horizontalSolution").querySelector("tbody");
  const vertTbody = document.getElementById("verticalSolution").querySelector("tbody");
  
  horizTbody.innerHTML = "";
  vertTbody.innerHTML = "";
  
  layouts.forEach(layout => {
    const row = document.createElement("tr");
    row.innerHTML = `
      <td class='idCol'>${layout.id || ""}</td>
      <td style="font-weight: 600;">${layout.word || ""}</td>
    `;
    
    if (layout.orientation === "H") {
      horizTbody.appendChild(row);
    } else {
      vertTbody.appendChild(row);
    }
  });
}

// FUN√á√ÉO RENDERIZADORA DE GRID OTIMIZADA - MOSTRA APENAS C√âLULAS ATIVAS
function renderGrid(msg) {
  const canvas = document.getElementById("gridCanvas");
  const ctx = canvas.getContext("2d");

  const nRows = parseInt(msg.rows.replace(/"/g, ""));
  const nCols = parseInt(msg.cols.replace(/"/g, ""));

  // Criar um mapa de c√©lulas ativas baseado nos layouts das palavras
  const activeCells = new Set();
  
  msg.layouts.forEach(layout => {
    const startRow = parseInt(layout.row);
    const startCol = parseInt(layout.col);
    const wordLength = layout.word.length;
    
    if (layout.orientation === "H") {
      // Palavra horizontal
      for (let i = 0; i < wordLength; i++) {
        activeCells.add(`${startRow},${startCol + i}`);
      }
    } else {
      // Palavra vertical
      for (let i = 0; i < wordLength; i++) {
        activeCells.add(`${startRow + i},${startCol}`);
      }
    }
  });

  // Calcular dimens√µes do grid baseado apenas nas c√©lulas ativas
  let minRow = nRows, maxRow = -1, minCol = nCols, maxCol = -1;
  
  activeCells.forEach(cellKey => {
    const [row, col] = cellKey.split(',').map(Number);
    minRow = Math.min(minRow, row);
    maxRow = Math.max(maxRow, row);
    minCol = Math.min(minCol, col);
    maxCol = Math.max(maxCol, col);
  });

  // Dimens√µes efetivas do grid (apenas √°rea com palavras)
  const effectiveRows = maxRow - minRow + 1;
  const effectiveCols = maxCol - minCol + 1;

  // Calcular tamanho das c√©lulas para melhor visualiza√ß√£o
  const maxCanvasSize = 600;
  const cellSize = Math.min(
    Math.floor(maxCanvasSize / effectiveCols),
    Math.floor(maxCanvasSize / effectiveRows),
    40
  );
  
  // Adicionar padding para os n√∫meros
  const padding = 20;
  canvas.width = cellSize * effectiveCols + padding * 2;
  canvas.height = cellSize * effectiveRows + padding * 2;

  ctx.clearRect(0, 0, canvas.width, canvas.height);
  
  // Configura√ß√µes de estilo aprimoradas
  ctx.font = `bold ${Math.max(cellSize / 3, 10)}px Arial`;
  ctx.textBaseline = "middle";
  ctx.textAlign = "center";

  // Desenhar apenas as c√©lulas ativas
  activeCells.forEach(cellKey => {
    const [absoluteRow, absoluteCol] = cellKey.split(',').map(Number);
    
    // Converter coordenadas absolutas para coordenadas relativas
    const relativeRow = absoluteRow - minRow;
    const relativeCol = absoluteCol - minCol;
    
    const x = relativeCol * cellSize + padding;
    const y = relativeRow * cellSize + padding;
    
    // Fundo branco para c√©lulas ativas
    ctx.fillStyle = "#ffffff";
    ctx.fillRect(x, y, cellSize, cellSize);
    
    // Bordas das c√©lulas
    ctx.strokeStyle = "#2d3748";
    ctx.lineWidth = 2;
    ctx.strokeRect(x, y, cellSize, cellSize);
  });

  // Desenhar n√∫meros das palavras nas posi√ß√µes iniciais
  ctx.fillStyle = "#2d3748";
  ctx.font = `bold ${Math.max(cellSize / 4, 9)}px Arial`;
  
  msg.layouts.forEach(layout => {
    const absoluteRow = parseInt(layout.row);
    const absoluteCol = parseInt(layout.col);
    
    // Converter para coordenadas relativas
    const relativeRow = absoluteRow - minRow;
    const relativeCol = absoluteCol - minCol;
    
    const x = relativeCol * cellSize + padding;
    const y = relativeRow * cellSize + padding;
    
    // Posicionamento diferenciado baseado na orienta√ß√£o
    let numberX, numberY;
    
    if (layout.orientation === "H") {
      // Palavra horizontal: n√∫mero no canto superior direito
      numberX = x + cellSize - 4;
      numberY = y + 12;
      ctx.textAlign = "right";
    } else {
      // Palavra vertical: n√∫mero no canto superior esquerdo
      numberX = x + 4;
      numberY = y + 12;
      ctx.textAlign = "left";
    }
    
    ctx.textBaseline = "top";
    ctx.fillText(layout.id || "", numberX, numberY);
  });

  // Mostrar canvas e esconder placeholder
  canvas.classList.remove("hidden");
  document.getElementById("canvasPlaceholder").style.display = "none";
  
  // Log para debug
  console.log(`Grid renderizado: ${effectiveRows}√ó${effectiveCols} c√©lulas ativas de ${nRows}√ó${nCols} total`);
}

function renderClues(layouts) {
  const horizTbody = document.getElementById("horizontalClues").querySelector("tbody");
  const vertTbody = document.getElementById("verticalClues").querySelector("tbody");
  
  horizTbody.innerHTML = "";
  vertTbody.innerHTML = "";
  
  layouts.forEach(layout => {
    const row = document.createElement("tr");
    row.innerHTML = `
      <td class='idCol'>${layout.id || ""}</td>
      <td>${layout.explanation || ""}</td>
    `;
    
    if (layout.orientation === "H") {
      horizTbody.appendChild(row);
    } else {
      vertTbody.appendChild(row);
    }
  });
}
</script>
</body>
</html>
